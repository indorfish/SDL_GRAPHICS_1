
SURFACES IN SDL
====================================================
Surfaces let us render stuff to the window.
We can create surfaces from scratch, but windows made with SDL_Createwindow(..) have associated surfaces by default.
This stuff is kinda complicated so I'll revisit it in detail later.

	SDL_GetWindowSurface(*)
		SDL_Surface *SDL_GetWindowSurface( SDL_Window *window );
	Beware!
	The surface is invalidated if the window is resized. If you want to avoid that,
	call the function again to return a valid surface for the new size.
	"You may not combine this with 3D or the rendering API on this window"


See these also:
	SDL_HasWindowSurface(*)
	SDL_DestroyWindowSurface(*)
	SDL_UpdateWindowSurface(*)
	SDL_UpdateWindowSurfaceRects(*)


SDL_FillRect is another useful function, although all it does is to fill rectangles with solid color.

	int SDL_FillRect( SDL_Surface *dest,
			  const SDL_Rect *rect,
			  Uint32 color );

Using this function is a bit tricky but nothing too confusing.
The 'dest' is a pointer to the SDL_Surface which is the target to be drawn on.
The 'rect' is the rectangle to be filled. I think the surfaces have a rectangle associated with them.
Return 0 on success, negative code on failure.


SDL_MapRGB(*)
This maps an RGB triple to an opaque pixel value for a given pixel format.

	Uint32 SDL_MapRGB( const SDL_PixelFormat *format,
			   Uint8 r, Uint8 g, Uint8 b);

Hmmm...for now, just think of it as something that takes 8-bit RGB and returns a single 32-bit integer that represents the value. Don't know the point of all this, but it'll make sense in due time.
OK...there's also the format, which is a string describing what format we want the color to be output in.
SDL documentation advises to use the same format as the surface in question.


SDL_UpdateWindowSurface(*)
Give me pointer to surface.


==============================================================

SDL_Rect
This represents a rectangle with its origin at the upper left (integer).

	typedef struct SDL_Rect {
		int x, y;
		int w, h;
	} SDL_Rect;


==============================================================

SAMPLE CODE AND EXPLANATION

	SDL_FillRect( winnie_the_window,
		      NULL,
		      SDL_MapRGB( winnie_the_window->format, 40, 40, 40 )
		    );

So, what is this SDL_MapRGB business?
Well, it's not strictly needed but it's more convenient to use.
The color argument to FillRect

	SDL_UpdateWindowSurface( winnie_the_window );


==============================================================
SIMPLE PROGRAM TO UPDATE THE COLOR OF A WINDOW'S SURFACE
We will increment the color every second or so.

	#include <SDL2/SDL.h>
	#define INIT_FLAG    SDL_INIT_EVERYTHING
	#define FAILURE	     1
	#define DELAY	     20
	#define RED	     50
	#define GREEN	     60

	int main(void)
	{
		int x;

		SDL_Init( INIT_FLAG );

		SDL_Window *winnie;
		SDL_Surface *surf;

		winnie = SDL_GetWindow( "Color-changing Window",
					SDL_WINDOWPOS_UNDEFINED, SDL_WINDOWPOS_UNDEFINED,
					1000, 800,
					SDL_WINDOW_BORDERLESS
				      );
		if (winnie == NULL)
			return (FAILURE);
		surf = SDL_GetWindowSurface( winnie );

		for (x = 0; x < 256 ; ++x)
		{
			SDL_FillRect( surf, NULL,
				      SDL_MapRGB(surf->format, RED, GREEN, x)
				    );
			SDL_UpdateWindowSurface( surf );
			SDL_Delay( DELAY );
		}
		SDL_Delay( 1000*DELAY);

		SDL_DestroyWindow( winnie );
		SDL_Quit();
		return (0);
	} 


==============================================================
FLOW SO FAR

1. Write code to initialize SDL and shut it down.
2. Write code to create a window. Make sure to check for errors, etc.
3. Write code for finer control e.g. event handling, or surface drawing.



==============================================================

PRECAUTIONS AND ISSUES

1. SDL_FillRect returns negative code upon failure.
We can't underscore this enough - never assume that a function successfully performs its job.

2. SDL_FillRect has a 'color' argument.
It should be a pixel of the format used by the surface, and can be generated by SDL_MapRGB(*) or
SDL_MapRGBA(*)
What this means? I have no idea.
